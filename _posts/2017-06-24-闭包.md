---
layout: post
title: "闭包"
date: 2018-06-24
description: "JavaScript,闭包"
tag:  JavaScript
---   


估计很多初学前端的同学都曾经被闭包所迷惑过吧，今天来说一下我所理解的闭包。

### 闭包是什么?

闭包就是一个普通的函数，但它的位置有点特殊——被包含在另一个函数里面。一个简单的例子：

	function f1(){
	  var name='john';
	  function f2(){
		alert(name);
	  }
	  return f2;
	}
在上面的代码中，f2就构成一个闭包，它被包含在f1函数中。

### 闭包有什么特性?

考虑如下代码：

	var result=f1();//将f1里的闭包函数f2赋值到result
	result();//'john'

正常情况下，第一行代码中f1函数执行完毕，其中的name变量也应该从内存中释放。但当执行第二行代码时，我们发现name变量的值还存在与内存中，可以被访问到。其实这就是闭包所拥有的特性：闭包函数被引用后会'抓住'父函数中的所有变量，不让它们销毁，始终保持在内存中，直到闭包的引用被销毁。

**怎么理解闭包的特性?**

通俗点理解，在执行第一行代码时，垃圾回收器发现f1函数已执行完毕，开始销毁f1函数中的name变量，但它发现result引用了f2函数，而f2函数引用了f1中的name。如果此时销毁name，那当result被调用时就将找不到name变量。因此，垃圾回收器不得不将name保存在内存中。说白了就是引用关系没解除的原因。

专业点说，当内部函数的作用域链在引用外部函数的活动对象时，虽然外部函数的作用域链被销毁，但其活动对象不会销毁。

### 闭包的例子与分析
**闭包的特性会导致一些有趣的现象**

**例一：**

	var fn = [];
	for (var i = 0; i < 3; i++) {
	  fn[i] = function () {
		console.log(i);
	  };
	}
	fn[0]();//3
	fn[1]();//3
	fn[2]();//3



分析：

>外部函数中的变量i存在于其活动对象中，可以简单理解为{i:0;other:...}，存储在内存中的某个位置(假设为0x0001)。当执行到第三行时，console.log(i)并没有被执行，其中的i指向了内存地址0x0001(三次循环都是)。当执行到 fn\[0\]() 时，外部函数的活动对象变成{i:3}。此时调用fn\[0\]，console.log(i)开始执行，去内存中寻找 i的值，得到的数值是3，因此输出为3。

这显然和预定的行为不符，如何修改呢?

利用匿名函数：


	var fn = [];
	for (var i = 0; i < 3; i++) {
	  fn[i] = function (i) {
		return function(){
		  console.log(i);
		}	
	  }(i);
	}
	fn[0]();//0
	fn[1]();//1
	fn[2]();//2

**例二：**

	var arr = ['A','B','C'];
	for(var i=0;i<arr.length;i++){
	  setTimeout(function(){
	    console.log(arr[i]);
	  },i*1000);
	}

依次在0，1，2秒的时候输出undefined

分析：

>setTimeout函数的第二个参数 i 是立即被执行的，因此依次取到0,1,2。而console.log(arr[i])中的i是放在异步任务队列中等待同步任务执行完才会从内存中取。同步任务执行完后，i的值变成3，因此执行console.log(arr[i])都为undefined。

### 闭包的注意事项

1.闭包引用的是外部函数的整个活动对象！因此，在上面的例子中，如果f1函数中还有age变量，age和name都存在与活动对象中，f2即使没引用age，age也会作为活动对象的一部分而一直存在于内存中，直到闭包被销毁。如果age变量是DOM元素，那么占用的内存资源将很大。因此，要尽量避免闭包的外部函数中存在DOM元素的情况。

2.闭包中的this的指向要看情况，如果闭包函数是用es5语法定义的，则在闭包函数被调用时才能确定this的指向，this指向调用者。如果是用es6的箭头函数定义，则闭包中的this指向其外部函数。

### 闭包的使用场景

**1.实现私有变量和特权方法**

	var person=(function(){
	  var name='john';
	  return {
		getName:function(){
		  return name;		
		},
		setName:function(newName){
		  name=newName;
		}
	  }
	}())


上面代码中不能直接访问person.name，因为name是其私有变量。但可以通过特权方法getName和setName来访问。

**2.单例模式**

	var getPersonSingleton = function(){
	  var person;
	  return function(){
	    return person || ( person = {name:'john'}))
	  }
	}()

通过调用getPersonSingleton()，返回的一直是同一个person对象，从而实现单例模式。